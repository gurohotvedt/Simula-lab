begin
  external class demos = "demos";
  demos begin

  ! variables;

  integer M; !max number of cars in each segment;
  integer V; !speed of single car on each segment;
  integer S; !length of segment;
  real gammaw; !arrival intensity of cars eastbound;
  real gamman; !northbound;
  real T; !time for green per car(s);
  integer Ts; !simtime;
  integer Nr; !numreplica;
  
  ref(rdist) cars;
  ref(res) array S(-5:5, -5,5);
  ref (condq) LQ;

end;
! Test av git edbynndring fra Nora;

BEGIN
  EXTERNAL CLASS demos;
  demos
    BEGIN
      ! comments start with "!" or "comment" and ends with ; ! even if ; ! is not on the same
        line;
      ! all variable names you choose are NOT casesensitive, meaning that NAVN is the same as
        navn is the same as Navn ....;
      ! here you define all you variables;
      REAL variables_of_type_real;
      INTEGER variables_of_type_integer;
      BOOLEAN variables_of_type_boolean;

      ! define random varaible;
      REF(rdist) random_variates_of_type_real (e.g., "NEGEXP");
      REF(idist) random_variates_of_type_integer (e.g., "UNIFORM");
      REF(bdist) random_variates_of_type_boolean (e.g., "DRAW");

      ! EXTRA: if two dimeninsional tables are needed, with 10+1 elements in each dimension;
      REAL ARRAY realvaule_tab(0:10,0:10);
      REF(rdist) ARRAY rdist_tab(0:10,0:10);
      ! EXAMPLE: the coordinate system of the assignment with a RES per segment;
      ! to constrain the number of cars per segment;
      REF(res) ARRAY S(-5:5,-5:5);

      ! same with waitq, condq, tally, etc...;
      REF (tally) stat;
      REF(waitq) ;
      REF(condq) LQ;

      entity CLASS entity_name(var1 ,...); INTEGER var1 ,... ;
      ! example with INTEGER type variable var1;
      BEGIN
        ! declare LOCAL variables;
        ! declarations of variables;
        ! (single bax in activity diagrams);
        ! loop: is here a label where you can "goto"
loop:
      ! (actions, assingments in single bax in activity diagrams;
      ! case ;
      ! NOTE: no semicolon before ELSE!!;
      IF check_is_true THEN
        something
      ELSE
        something_ELSE;
      ! or ;
      IF check_is_true THEN
        ! always BEGIN END WHEN more than one statement;
        BEGIN
          something;
          continued;
        END
      ELSE
        BEGIN
          something_ELSE;
          continued;
        END;

      ! wait for a condition - e.g., green light, use condq;
      LQ.Wait(green_ligth_is_true);
      ! WHEN the state of the traffic light changes a signals has to be sent to the LQ so the
        condition of all the waiting entities is cheched; ! using : LQ.signal;
      GOTO stop;
      ! if loop indefinite you need repeat and loop:, executions jumps to loop: ;
      repeat;
stop:
      END;


      ! parameters ;
      ! ex;
      numreplica := 10;

      ! resources;
      ! ex - loop and define three RES instances named ball;
      FOR i:=1 STEP 1 UNTIL 3 DO
        ball :- NEW res("name of ball",1);
      ! or;
      FOR i:=1,2,3 DO
        ball :- NEW res("name of ball",1);

      ! random variable;
      most_common_var :- NEW NegExp("always me", rate);

      ! statistics;
      ! ex;
      tell :- NEW tally("Telle");

      ! condq;
      ! ex;
      CQ :- NEW condq("conditon queue");
      ! if you want all conditions to be checked every time - if not it will stop when the first
          FALSE is detected;
      LQ.all := TRUE;

      ! waitq;
      ! ....;

      ! ALTERNATIVE 1: single run;
      NEW enitiy_NAME("name of entity").schedule(sometime);
      ! run - time terminated after simtime;
      Hold(simtime);

      ! ALTERNATIVE 2: multiple runs (numreplica);
      WHILE replication LE numreplica DO
        BEGIN
        ! init entity - starts "sometime" after current sim time ;
        NEW enitiy_NAME("name of entity").schedule(sometime);
        ! run - time terminated after simtime;
        Hold(simtime);
        ! do not print a report after each replica;
        noreport;
        ! replicate - new run, same parameters, new seed to random number generator;
        replicate;
      END;
    END;
END;
